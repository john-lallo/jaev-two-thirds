<!DOCTYPE HTML>
<html>
<head>
	<title>jaev-2/3</title>
	<style>
		html, body{
			background-color: #111;
			margin: 0;
			border: 0;
		}

		#world {
			margin: 24px;
			position: relative;

			border: 1px dashed #aaa;

			width: 720px;
			height: 720px;

			cursor: default;

			overflow: hidden;
		}

		.P {
			position: absolute;
			width: 8px; height: 8px;

			border: 3px solid #222;
			border-radius: 100%;

			cursor: default;

  			/*box-shadow: 0 0 0 4px #222;*/
		}

		.P-core{
			position: absolute;
			
			top: 1px; bottom: 1px;
			left: 1px; right: 1px;

			border: 1px solid #aaa;
			border-radius: 100%;

			cursor: default;
		}

		.solid { background-color: #aaa; }

		.shaft {
			position: absolute;
			height: 1px;
			background-color: #aaa;

			-webkit-transform-origin: center left;

			z-index: 1000;

			cursor: default;
		}

		.K {
			position: absolute;
			width: 4px; height: 4px;

			background-color: #f93;
			border-radius: 100%;

			cursor: default;

  			/*box-shadow: 0 0 0 4px #222;*/
		}
	</style>

	<script src = "https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
	<script src = "numeric.js"></script>
	<script language = "javascript">

		/* global */
		var dt = 0.1;

		var world_offset = [0, 0];
		var world_dimens = [0, 0];

		var g = [0, 0];//-9.81];

		/* point mass */
		var point = function(i, mass, q, v){
			this.i = i;
			this.m = mass;

			this.invm = 1/mass;

			this.q = q;
			this.qprev = [q[0] - v[0]*dt, q[1] - v[1]*dt];

			this.elem = null;
		}

		point.prototype.render = function(){
			var elem_str =
			'<div id = "P' + this.i + '" class = "P solid" ' +
			'style = "bottom: -7px; left: -7px"><div class = "P-core"></div></div>';
		
			$("#world").append(elem_str);
			this.elem = $("#P" + this.i);
			this.sync();

			this.elem.on('mousedown', function(e){
				var i = $(this).attr('id').substring(1);
				P[i].startDrag();
			});

		}

		point.prototype.sync = function(){
			this.elem.css({
				"-webkit-transform" : "translate("
				+ this.q[0] + "px, "
				+ (-this.q[1]) + "px)"
			});
		}

		/* (interactivity) */

		var Q = [0, 0];
		var drag_i = 0;
		var ON = false;

		function update_Q(e){
			Q = [
			(e.pageX - world_offset[0]),
			(world_dimens[1] - e.pageY + world_offset[1])
			];
		}

		point.prototype.startDrag = function(){ drag_i = this.i; ON = true; }
		function stopDrag(){ ON = false; }





		/* constraint */
		var constraint = function(i, A, B){

			this.i = i;
			this.A = A; this.B = B;

			this.elem = null;
		}
		constraint.prototype.condition = function() { return true; }
		constraint.prototype.C = function() { return 0;	}
		constraint.prototype.solve = function(){
		if(this.condition()){
			var nablaC = this.nablaC();
			var nablaCT = numeric['transpose'](nablaC);

			var W = [
				[this.A.invm, 0, 0, 0],
				[0, this.A.invm, 0, 0],
				[0, 0, this.B.invm, 0],
				[0, 0, 0, this.B.invm]
			];

			var WnablaCT = numeric['dot'](W, nablaCT);

			var nablaCWnablaCT =
			numeric['dot'](nablaC, WnablaCT);

			var lambda =
			numeric['*'](
				numeric['inv'](nablaCWnablaCT), numeric['*'](-1, this.C())
			);

			var dP = numeric['dot'](WnablaCT, lambda);

			//update positions
			this.A.q = numeric['+'](this.A.q, [dP[0][0], dP[1][0]]);
			this.B.q = numeric['+'](this.B.q, [dP[2][0], dP[3][0]]);
		}
		}

		/* constraint: dist constraint */
		function dist_constraint(i, A, B){
			constraint.call(this, i, A, B);
			var D = numeric['-'](this.A.q, this.B.q);
			this.D = Math.sqrt(D[0]*D[0] + D[1]*D[1]);
		}
		dist_constraint.prototype = Object.create(constraint.prototype);
		dist_constraint.prototype.constructor = dist_constraint;

		dist_constraint.prototype.C = function(){
			var d = numeric['-'](this.A.q, this.B.q);
			return ((d[0]*d[0] + d[1]*d[1]) - this.D*this.D)/2;
		}
		
		dist_constraint.prototype.nablaC = function(){
			var nablaC = [[
				this.A.q[0] - this.B.q[0],
				this.A.q[1] - this.B.q[1],
				this.B.q[0] - this.A.q[0],
				this.B.q[1] - this.A.q[1],
			]];
			return nablaC;
		}

		dist_constraint.prototype.render = function(){

			var elem_str =
			'<div id = "C' + this.i + '" class = "shaft" ' +
			'style = "bottom: 0px; left: 0px"></div>';
		
			$("#world").append(elem_str);
			this.elem = $("#C" + this.i);
			this.sync();
		}

		dist_constraint.prototype.sync = function(){
			var d = numeric['-'](this.A.q, this.B.q);
			d = Math.sqrt(d[0]*d[0] + d[1]*d[1]);

			var th = Math.acos((this.B.q[0] - this.A.q[0]) / d) *
					(this.B.q[1] - this.A.q[1] > 0 ? 1 : -1);

			this.elem.css({
				"width" : (d) + "px",
				"-webkit-transform" : "translate("
				+ this.A.q[0] + "px, "
				+ (-this.A.q[1]) + "px) rotate(" + (-th) + "rad)"
			});
		}


		/* constraint: collision constraint */
		function k_constraint(i, A, B, P){
			constraint.call(this, i, A, B);
			this.P = P;
		}
		k_constraint.prototype = Object.create(constraint.prototype);
		k_constraint.prototype.constructor = k_constraint;

		k_constraint.prototype.condition = function(){
			return (X(this.A.q, this.B.q, this.P.q) * X(this.A.qprev, this.B.qprev, this.P.qprev) > 0);
		}
		k_constraint.prototype.C = function(){
			return X(this.B.q, this.A.q, this.P.q);
		}
		k_constraint.prototype.nablaC = function() {
			var e = 1e-6;
			var C0 = this.C();

			var nablaC = [[]];
			this.A.q[0]+=e; nablaC[0][0] = (this.C()-C0)/e; this.A.q[0]-=e;
			this.A.q[1]+=e; nablaC[0][1] = (this.C()-C0)/e; this.A.q[1]-=e;
			this.B.q[0]+=e; nablaC[0][2] = (this.C()-C0)/e; this.B.q[0]-=e;
			this.B.q[1]+=e; nablaC[0][3] = (this.C()-C0)/e; this.B.q[1]-=e;
			this.P.q[0]+=e; nablaC[0][4] = (this.C()-C0)/e; this.P.q[0]-=e;
			this.P.q[1]+=e; nablaC[0][5] = (this.C()-C0)/e; this.P.q[1]-=e;

			return nablaC;
		}
		k_constraint.prototype.solve = function(){
		if(this.condition()){
			var nablaC = this.nablaC();
			var nablaCT = numeric['transpose'](nablaC);

			var W = [
				[this.A.invm, 0, 0, 0, 0, 0],
				[0, this.A.invm, 0, 0, 0, 0],
				[0, 0, this.B.invm, 0, 0, 0],
				[0, 0, 0, this.B.invm, 0, 0],
				[0, 0, 0, 0, this.P.invm, 0],
				[0, 0, 0, 0, 0, this.P.invm]
			];

			var WnablaCT = numeric['dot'](W, nablaCT);

			var nablaCWnablaCT =
			numeric['dot'](nablaC, WnablaCT);

			var lambda =
			numeric['*'](
				numeric['inv'](nablaCWnablaCT), numeric['*'](-1, this.C())
			);

			var dP = numeric['dot'](WnablaCT, lambda);

			//update positions
			this.A.q = numeric['+'](this.A.q, [dP[0][0], dP[1][0]]);
			this.B.q = numeric['+'](this.B.q, [dP[2][0], dP[3][0]]);
			this.P.q = numeric['+'](this.P.q, [dP[4][0], dP[5][0]]);
		}
		}

		k_constraint.prototype.render = function(){
		
			var elem_str =
			'<div id = "K' + this.i + '" class = "K" ' +
			'style = "bottom: 0px; left: 0px; -webkit-transform: translate(' +
				+ this.P.q[0] + 'px, '
				+ (-this.P.q[1]) + 'px)"></div>';
		
			$("#world").append(elem_str);
		}
		k_constraint.prototype.sync = function(){ return; }


		/* collision detection */

		//maths
		function X(O, A, B){ return ((A[0]-O[0])*(B[1]-O[1]) - (A[1]-O[1])*(B[0]-O[0])); }
		function contains(A, B, C, P){
			return (X(A, B, P) * X(B, C, P) > 0) && (X(B, C, P) * X(C, A, P) > 0);
		}

		//main routine
		function fetchCollision(A, B, P){

			var a0 = numeric['-'](A.qprev, P.qprev);
			var b0 = numeric['-'](B.qprev, P.qprev);
			var a1 = numeric['-'](A.q, P.q);
			var b1 = numeric['-'](B.q, P.q);

			var count = 0;

			if(contains(a0, a1, b1, [0, 0])){ ++count; }
			if(contains(a1, b1, b0, [0, 0])){ ++count; }
			if(contains(b1, b0, a0, [0, 0])){ ++count; }
			if(contains(b0, a0, a1, [0, 0])){ ++count; }

			if(count == 2){
			//a loop of four triangles containing an iterior point exactly twice

			//console.log('KOL');

			return true;

			} else { return false; }
		}












		/* collision detection, with all constraint shafts tangible */
		function collide(){
			klabel = 0;
			K = [];			

			P.forEach(function(p){
			C.forEach(function(c){
				if(!((p.i == c.A.i) || (p.i == c.B.i))){

					var k = fetchCollision(c.A, c.B, p);
					if(k){
						K[klabel] = new k_constraint(klabel, c.A, c.B, p);
						K[klabel].render(); ++klabel;
					}

				}
			});
			});
		}

		




		/* solve constraints */
		function constrain(){
			for(var i = 0; i < 12; ++i){
			C.forEach(function(c){ c.solve(); });
			K.forEach(function(k){ k.solve(); });
			}
		}

		/* integrate laws of motion */
		function integrate(){
			P.forEach(function(p){
				var a = g;
				var qnext =
				numeric['+'](numeric['-'](numeric['*'](2, p.q), p.qprev), numeric['*'](a, dt*dt));

				p.qprev = p.q; p.q = qnext;
			})

			//handle dragging
			if(ON){ P[drag_i].q = Q; }
		}


		/* one simulation step. */
		var t = 0.1;
		function timestep(){
			++t;
			//if(t == 120){ P[0].q[0] += 100; P[1].q[0] -= 100; }

			integrate();
			constrain();

			P.forEach(function(p){ p.sync(); });
			C.forEach(function(c){ c.sync(); });

			//placeholder
			collide();
		}



		var P = [];	//particles
		var C = [];	//constraints
		var K = [];	//[k/c]ollision constraints

		var plabel = 0;
		var clabel = 0;
		var klabel = 0;
		/* construct world */
		function init(){

			//var V = [];

			P[plabel] = new point(plabel, 1, [400, 480], [0, 0]); P[plabel].render(); ++plabel;
			P[plabel] = new point(plabel, 1, [400, 440], [0, 0]); P[plabel].render(); ++plabel;
			P[plabel] = new point(plabel, 1, [400, 400], [0, 0]); P[plabel].render(); ++plabel;
			P[plabel] = new point(plabel, 1, [400, 360], [0, 0]); P[plabel].render(); ++plabel;
			P[plabel] = new point(plabel, 1, [390, 320], [0, 0]); P[plabel].render(); ++plabel;
			P[plabel] = new point(plabel, 1, [410, 320], [0, 0]); P[plabel].render(); ++plabel;

			P[plabel] = new point(plabel, 1, [480, 580], [0, 0]); P[plabel].render(); ++plabel;
			P[plabel] = new point(plabel, 1, [200, 520], [0, 0]); P[plabel].render(); ++plabel;

			C[clabel] = new dist_constraint(clabel, P[0], P[1]); C[clabel].render(); ++clabel;
			C[clabel] = new dist_constraint(clabel, P[1], P[2]); C[clabel].render(); ++clabel;
			C[clabel] = new dist_constraint(clabel, P[2], P[3]); C[clabel].render(); ++clabel;
			C[clabel] = new dist_constraint(clabel, P[3], P[4]); C[clabel].render(); ++clabel;
			C[clabel] = new dist_constraint(clabel, P[4], P[5]); C[clabel].render(); ++clabel;
			C[clabel] = new dist_constraint(clabel, P[5], P[3]); C[clabel].render(); ++clabel;


			C[clabel] = new dist_constraint(clabel, P[6], P[7]); C[clabel].render(); ++clabel;
		
		}


		$(document).ready(function(){

			world_dimens = [$('#world').width(), $('#world').height()];
			world_offset = [$('#world').offset().left, $('#world').offset().top];

			$(document).on('mousemove', update_Q);
			$(document).on('mouseup', stopDrag);

			init();

			window.setInterval(timestep, 160 * dt);
		});


	</script>
</head>

<body>
	<div id = "world">
	</div>


</body>

</html>
