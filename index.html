<!DOCTYPE HTML>
<html>
<head>
	<title>jaev-2/3</title>
	<style>
		html, body{
			background-color: #111;
			margin: 0;
			border: 0;
		}

		#world {
			margin: 24px;
			position: relative;

			border: 1px dashed #aaa;

			width: 720px;
			height: 720px;

			cursor: default;

			overflow: hidden;
		}

		.P {
			position: absolute;
			width: 8px; height: 8px;

			border: 3px solid #222;
			border-radius: 100%;

			cursor: default;

  			/*box-shadow: 0 0 0 4px #222;*/
		}

		.P-core{
			position: absolute;
			
			top: 1px; bottom: 1px;
			left: 1px; right: 1px;

			border: 1px solid #aaa;
			border-radius: 100%;

			cursor: default;
		}

		.solid { background-color: #aaa; }

		.shaft {
			position: absolute;
			height: 1px;
			background-color: #aaa;

			-webkit-transform-origin: center left;

			z-index: 1000;

			cursor: default;
		}
	</style>

	<script src = "https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
	<script src = "numeric.js"></script>
	<script language = "javascript">

		/* global */
		var dt = 0.1;

		var world_offset = [0, 0];
		var world_dimens = [0, 0];

		var g = [0, 0];//-9.81];

		/* point mass */
		var point = function(i, mass, q, v){
			this.i = i;
			this.m = mass;

			this.invm = 1/mass;

			this.q = q;
			this.qprev = [q[0] - v[0]*dt, q[1] - v[1]*dt];

			this.elem = null;
		}

		point.prototype.render = function(){
			var elem_str =
			'<div id = "P' + this.i + '" class = "P solid" ' +
			'style = "bottom: -7px; left: -7px"><div class = "P-core"></div></div>';
		
			$("#world").append(elem_str);
			this.elem = $("#P" + this.i);
			this.sync();

			this.elem.on('mousedown', function(e){
				var i = $(this).attr('id').substring(1);
				P[i].startDrag();
			});

		}

		point.prototype.sync = function(){
			this.elem.css({
				"-webkit-transform" : "translate("
				+ this.q[0] + "px, "
				+ (-this.q[1]) + "px)"
			});
		}

		/* (interactivity) */

		var Q = [0, 0];
		var drag_i = 0;
		var ON = false;

		function update_Q(e){
			Q = [
			(e.pageX - world_offset[0]),
			(world_dimens[1] - e.pageY + world_offset[1])
			];
		}

		point.prototype.startDrag = function(){ drag_i = this.i; ON = true; }
		function stopDrag(){ ON = false; }





		/* constraint */
		var constraint = function(i, A, B){
			this.i = i;
			this.A = A; this.B = B;

			this.elem = null;
		}
		constraint.prototype.C = function() { return 0;	}
		constraint.prototype.nablaC = function() { return [[0, 0, 0, 0]]; }
		constraint.prototype.solve = function(){
			var nablaC = this.nablaC();
			var nablaCT = numeric['transpose'](nablaC);

			var W = [
				[this.A.invm, 0, 0, 0],
				[0, this.A.invm, 0, 0],
				[0, 0, this.B.invm, 0],
				[0, 0, 0, this.B.invm]
			];

			var WnablaCT = numeric['dot'](W, nablaCT);

			var nablaCWnablaCT =
			numeric['dot'](nablaC, WnablaCT);

			var lambda =
			numeric['*'](
				numeric['inv'](nablaCWnablaCT), numeric['*'](-1, this.C())
			);

			var dP = numeric['dot'](WnablaCT, lambda);

			//update positions
			this.A.q = numeric['+'](this.A.q, [dP[0][0], dP[1][0]]);
			this.B.q = numeric['+'](this.B.q, [dP[2][0], dP[3][0]]);
		}

		/* constraint: dist constraint */
		function dist_constraint(i, A, B){
			constraint.call(this, i, A, B);
			var D = numeric['-'](this.A.q, this.B.q);
			this.D = Math.sqrt(D[0]*D[0] + D[1]*D[1]);
		}
		dist_constraint.prototype = Object.create(constraint.prototype);
		dist_constraint.prototype.constructor = dist_constraint;

		dist_constraint.prototype.C = function(){
			var d = numeric['-'](this.A.q, this.B.q);
			return ((d[0]*d[0] + d[1]*d[1]) - this.D*this.D)/2;
		}
		dist_constraint.prototype.nablaC = function(){
			var nablaC = [[
				this.A.q[0] - this.B.q[0],
				this.A.q[1] - this.B.q[1],
				this.B.q[0] - this.A.q[0],
				this.B.q[1] - this.A.q[1],
			]];
			return nablaC;
		}


		dist_constraint.prototype.render = function(){

			var elem_str =
			'<div id = "C' + this.i + '" class = "shaft" ' +
			'style = "bottom: 0px; left: 0px"></div>';
		
			$("#world").append(elem_str);
			this.elem = $("#C" + this.i);
			this.sync();
		}

		dist_constraint.prototype.sync = function(){
			var d = numeric['-'](this.A.q, this.B.q);
			d = Math.sqrt(d[0]*d[0] + d[1]*d[1]);

			var th = Math.acos((this.B.q[0] - this.A.q[0]) / d) *
					(this.B.q[1] - this.A.q[1] > 0 ? 1 : -1);

			this.elem.css({
				"width" : (d) + "px",
				"-webkit-transform" : "translate("
				+ this.A.q[0] + "px, "
				+ (-this.A.q[1]) + "px) rotate(" + (-th) + "rad)"
			});
		}


		/* collision detection */

		function fetchCollision(A, B, P){

			var ABxAP = (B.q[0] - A.q[0]) * (P.q[1] - A.q[1]) - (B.q[1] - A.q[1]) * (P.q[0] - A.q[0]);
			var ABxAX = (B.q[0] - A.q[0]) * (P.qprev[1] - A.q[1]) - (B.q[1] - A.q[1]) * (P.qprev[0] - A.q[0]);

			//console.log(ABxAP*ABxAX);
			if(ABxAP*ABxAX <= 0){
				//console.log('COLLISION' + (ABxAP*ABxAX));

				var x1 = A.q[0]; var y1 = A.q[1];
				var x2 = B.q[0]; var y2 = B.q[1];
				var x3 = P.q[0]; var y3 = P.q[1];
				var x4 = P.qprev[0]; var y4 = P.qprev[1];

				var X =
				((x1*y2-y1*x2)*(x3-x4)-(x1-x2)*(x3*y4-y3*x4)) / 
				((x1-x2)*(y3-y4)-(y1-y2)*(x3-x4));
				var Y =
				((x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4)) / 
				((x1-x2)*(y3-y4)-(y1-y2)*(x3-x4));

				console.log('COLLISION: ' + X + ',' + Y)

			} else { return false; }
			/*


			*/
		}












		/* collision detection, with all constraint shafts tangible */
		function collide(){
			
			P.forEach(function(p){
			C.forEach(function(c){
				if(!((p.i == c.A.i) || (p.i == c.B.i))){
				fetchCollision(c.A, c.B, p);
				}
			});
			});
		}

		




		/* solve constraints */
		function constrain(){
			for(var i = 0; i < 12; ++i){
			C.forEach(function(c){ c.solve(); });
			}
		}

		/* integrate laws of motion */
		function integrate(){
			P.forEach(function(p){
				var a = g;
				var qnext =
				numeric['+'](numeric['-'](numeric['*'](2, p.q), p.qprev), numeric['*'](a, dt*dt));

				p.qprev = p.q; p.q = qnext;
			})

			//handle dragging
			if(ON){ P[drag_i].q = Q; }
		}


		/* one simulation step. */
		var t = 0;
		function timestep(){
			++t;
			//if(t == 120){ P[0].q[0] += 100; P[1].q[0] -= 100; }

			integrate();
			constrain();

			P.forEach(function(p){ p.sync(); });
			C.forEach(function(c){ c.sync(); });

			//placeholder
			collide();
		}



		var P = [];	//particles
		var C = [];	//constraints
		var K = [];	//[k/c]ollision constraints

		var plabel = 0;
		var clabel = 0;
		/* construct world */
		function init(){

			//var V = [];

			P[plabel] = new point(plabel, 1, [400, 500], [0, 0]); P[plabel].render(); ++plabel;
			P[plabel] = new point(plabel, 1, [500, 600], [0, 0]); P[plabel].render(); ++plabel;
			P[plabel] = new point(plabel, 1, [200, 550], [60, 40]); P[plabel].render(); ++plabel;
			P[plabel] = new point(plabel, 1, [250, 550], [60, -40]); P[plabel].render(); ++plabel;

			C[clabel] = new dist_constraint(clabel, P[0], P[1]); C[clabel].render(); ++clabel;
			C[clabel] = new dist_constraint(clabel, P[2], P[3]); C[clabel].render(); ++clabel;
		}


		$(document).ready(function(){

			world_dimens = [$('#world').width(), $('#world').height()];
			world_offset = [$('#world').offset().left, $('#world').offset().top];

			$(document).on('mousemove', update_Q);
			$(document).on('mouseup', stopDrag);

			init();

			window.setInterval(timestep, 160 * dt);
		});


	</script>
</head>

<body>
	<div id = "world">
	</div>


</body>

</html>
